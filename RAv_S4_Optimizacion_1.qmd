---
title: 'R avanzado. Sesión 4: Optimización 1'
author: "Jorge de la Vega"
institute: ITAM
lang: es
date: today
format:
  html:
    page-layout: full
    embed-resources: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(rgl)
library(pracma)
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", fig.height = 5)
knitr::knit_hooks$set(webgl = hook_webgl)
```

# Consideraciones generales 

- Usualmente los problemas se plantean como problemas de minimización. Para encontrar máximos, buscamos el mínimo del negativo de una función. 

- Las dificultades en optimización surgen de la dificultad de distinguir mínimos locales de mínimos globales, sobre todo en las funciones multidimensionales. Usualmente la manera de distinguirlos es por ensayo y error. 

- [Task-view en R](http://cran.r-project.org/web/views/Optimization.html): muestra los avances y los paquetes desarrollados para optimización. 

R tiene tres funciones en el paquete `base` para temas de optimización:

- `optimize()`: para problemas de una dimensión.
- `optim()`: para problemas multidimensionales
- `constrOptim()`: para optimización  con restricciones lineales

Paquetes importantes: 

- `nloptr`: uno de los paquetes más completos para optimización en R. El paquete es una interfase a la biblioteca de código abierto `NLopt` para optimización no lineal.



# Ejemplos para funciones de una variable

La función `optimize` usa el método de Brent, que combina encasillamiento de raíces, bisección e interpolación cuadrática inversa.

## Ejemplo 1.

Considerar una función que da el volumen de una caja a partir de una hoja de cartón de 16x20, y x es el tamaño de los cuadrados cortados en las esquinas. 

```{r}
f <- function(x)x*(20-2*x)*(16-2*x)
curve(f, from = 0, to=8)
abline(h=0)

optimize(f,interval = c(0,8), maximum = T)
```

## Ejemplo 2. 

La función $f(x) = x\sin(4x)$ en el intervalo [0,3] tiene un mínimo local y un mínimo global, y dos máximos, uno local y uno global. 

```{r}
f <- function(x)x*sin(4*x)
curve(f, from = 0, to = 3)
optimize(f, interval = c(0,3)) # devuelve sólo un mínimo local
```

Devuelve el primer valor que encuentra en el dominio. Podemos encontrar el otro valor tomando un intervalo adecuado, (lo que podemos hacer porque podemos ver la gráfica)

```{r}
optimize(f, interval = c(1.5,3))
```

El paquete `pracma` tiene una función `findmins` que da todas los valores de los mínimos encontrados, dividiendo en $n$ secciones el intervalo y aplicando `optimize` en cada subintervalo. 

```{r}
require(pracma)
f.mins <- findmins(f,0,3)
f.mins
f(f.mins) # Evalua la función en los mínimos
g <-function(x) -f(x)
f.max <- findmins(g,0,3) # Para buscar los máximos
f.max
f(f.max) # Evalúa la función en los máximos
```

Potenciales problemas: 

- Para funciones muy planas, se pueden obtener soluciones erróneas cuando el intervalo de evaluación no se elige bien. Se debe combinar el estudio de la gráfica con selección de intervalos

- Soluciones en los extremos de los intervalos pueden no encontrarse. Por ejemplo, con la función $f(x)= |x^2-8|$.

```{r}
f <- function(x)abs(x^2-8)
curve(f, from = -4, to = 4)
```

Optimizando en el intervalo, obtenemos una de las soluciones internas.
```{r}
optimize(f, interval = c(-4,4))
```


Si excluimos la parte central, se encuentra el máximo en los extremos en ambos lados: 
```{r}
optimize(f, interval = c(-4,-2),maximum = T)
optimize(f, interval = c(2,4), maximum = T)
```


Pero `findmins` no incluye los extremos, porque la función aplica `optimize` a dos _intervalos adyacentes_, y eso no se puede en los extremos, sólo lo aplica a un intervalo.

```{r}
findmins(function(x)-f(x), -4,4)
findmins(function(x)-f(x), -4,-3)
```

## Método de la sección dorada

El método de búsqueda de la sección dorada es una forma simple de minimizar una función que tiene un valor mínimo en el intervalo $[a,b]$. Este método aplica la continuidad de la función. El método puede ser de utilidad cuando no existe la derivada en todos los puntos del dominio de la función. 
		
Por ejemplo, consideren minimizar la función $f(x) = |x-3.5| + (x-2)^2$ en el intervalo $[0,5]$. Vemos una gráfica de esta función:


```{r}
f <- function(x){abs(x-3.5) + (x-2)^2}
curve(f, from = 1, to = 5, n = 500, lwd=2,ylim=c(1,11))
points(c(1,1.9,2.5,3.5,5),c(f(1),f(1.9),f(2.5),f(3.5),f(5)),pch=16,cex=1.1)
text(1,3.5,"a",cex = 1.2,pos=3)
text(1,3.5,"a'",cex = 1.2,pos=1)
text(1.9,f(1.9),"x1'",cex = 1.2,pos=1)
text(2.5,f(2.5),"x2'",cex = 1.2,pos=1)
text(2.5,f(2.5),"x1",cex = 1.2,pos=3)
text(3.5,f(3.5),"x2",cex = 1.2,pos=3)
text(3.5,f(3.5),"b'",cex = 1.2,pos=1)
text(5,f(5),"b",cex = 1.2,pos=3)
```
			
La función no es diferenciable en $x=3.5$ porque tiene un "pico". El método de la sección dorada es un método iterativo que tiene el siguiente procedimiento:

El algoritmo procede de la siguiente manera: 

1. Comienza con el intervalo $[a,b]$, que se supone que contiene el mínimo.
2. De manera repetida, lo vamos encogiendo, obteniendo intervalos más y más pequeños $[a',b']$ que contienen el valor de $x$ con el mínimo.
3. Detenerse cuando $b'-a'< \varepsilon$, donde $\varepsilon$ es elegido como tolerancia.			

Cuando la búsqueda se detiene, el punto medio del intervalo final, con un error máximo de $(b'-a')/2$

El problema en este algoritmo es saber cómo ir reduciendo los intervalos. Para eso se usa el número que se conoce como **razón dorada**:
		
$$\phi = \frac{1+ \sqrt{5}}{2}$$
		
Este número tiene propiedades muy interesantes. Por ejemplo, $\phi^2 = \phi+1$, $\phi-1 = 1/\phi$, $1/\phi^2 = 1-1/\phi$ entre otras.
		
El algoritmo procede de esta manera:

- Empieza con $[a,b]$.
- Elige $x_1 < x_2, \qquad x_i \in [a,b]$
- Si $f(x_1) > f(x_2)$, el mínimo está entre $[x_1,b]$
- Si $f(x_1) < f(x_2)$, el mínimo está entre $[a,x_2]$
- Los puntos interiores son elegidos tal que 
$$ x_1 = b-\frac{b-a}{\phi} \mbox{ y } x_2 = a+\frac{b-a}{\phi}$$
- Después de una iteración se puede descartar $a$ y reemplazar con $a'=x_1$. El nuevo valor de $x_1$ es 
\begin{eqnarray*}
x_1' &=& b - (b-a')/\phi \\
     &=& b- (b-x_1)/\phi \\
     &=& b - (b-(b-a)/\phi)/\phi \\
     &=& b - (b-a)/\phi^2 \\
     &=& b- (b-a)(1-1/\phi) \\
     &=& b- (b-a) + (b-a)/\phi \\
     &=& a + (b-a)/\phi = x_2
\end{eqnarray*}

El algoritmo queda: 
```{r}
dorada <- function(f, a, b, tol = 0.00000001){
			rd <- (sqrt(5)+1)/2
			x1 <- b - (b-a)/rd
			x2 <- a + (b-a)/rd
			f1 <- f(x1)
			f2 <- f(x2)
			while(abs(b-a) > tol){
				if (f2 > f1){
					b <- x2
					x2 <- x1
					f2 <- f1
					x1 <- b - (b-a)/rd
					f1 <- f(x1)
				} else {
					a <- x1
					x1 <- x2 
					f1 <- f2
					x2 <- a + (b-a)/rd
					f2 <- f(x2)
				}
			}
			return((a+b)/2)}
```

		
Podemos evaluar la función:

```{r}
x0 <- dorada(f, 1, 5) # Encuentra el punto del dominio donde la fn alcanza el mín.
f(x0) # evalúo el punto crítico. Devuelve el valor mínimo de la fn.
curve(f, from = 0, to = 5, n = 500, lwd = 2)
abline(v = x0, h = f(x0))
```
		
Otro ejemplo: aplicar el método a la función $f(x)=|x-3.5| + |x-2| + |x-1|$. En este caso encuentra el mínimo que está justo en un pico. 

```{r}
f1 <- function(x){abs(x-3.5) + abs(x-2) + abs(x-1)}
       curve(f1, 0, 5)
		   dorada(f1, 0, 5)
```

La siguiente sesión será optimización para funciones multivariadas. 